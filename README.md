# What is GiBBERISh

**GiBBERISh** stands for ***Git and Bash Based Encrypted Remote Interactive Shell***. It is just a slow (but *free*, *easy* and *portable*) way to <u>*securely* access your *Linux* computer from any other *Linux* box over the internet, when none of the machines has a public IP address</u>. <u>You can also transfer files to and fro the remote host, with end-to-end encryption.</u>

It consists of only a short *Bash* *script* to be run on both the hosts (viz. client and server), and a free online git repository, owned and controlled by the user (such as a free repository in https://github.com/, https://gitlab.com/, https://bitbucket.org/ or https://sourceforge.net/).

# Why GiBBERISh

The standard way to access a remote computer is Secure Shell or **SSH**. But, in order to connect to the remote host *over the internet*, it has to have a public IP address -- something most personal and work PCs don't have access to. You can, however, beat this in the following ways:

1. **SSH port forwarding** at a server with public IP (e.g. check out https://sshreach.me/)
2. Virtual Private Network or **VPN**  (just google; there are lots of such services)

<u>If you can afford any of the above, then GiBBERISh is definitely not for you.</u> However, if you are like me, who doesn't want to pay for a port-forwarding or VPN service, you are probably out of luck with SSH. 

However, you can still manage fine with a free remote access app, such as **TeamViewer**. <u>If you are happily using such Virtual Network Computing (VNC), then too you won't have any use for GiBBERISh.</u> I, however, faced a lot of problems connecting two different versions of Ubuntu using TeamViewer. That probably is my bad, but it seems likely that such intricate apps come with their own portability issues, apart from the fact that they usually depend on a lot of other packages, installing which might be taxing for the inexperienced user. Dependence on VNC apps thus didn't seem too reliable. I, therefore, needed, a light-weight, portable, easy to install and completely cost-FREE option to access my remote machine securely over the internet. I didn't mind the latency, as long as my main purpose of submitting jobs to the remote host was served. Hence, my DIY solution - GiBBERISh.

# How it works

*An interactive shell is nothing but the user chatting with the operating system (OS), occasionally poking the OS with interrupt signals*. For GiBBERISh, the user's local machine is the *client*, and the OS in the remote host is the *server*. Correspondence between the two is managed by an automated *Git* workflow.

*Git*, if you don't know about it already, is a widely-used, fast, lightweight, distributed version-control system or content-tracker. Because it is distributed, widely available, and easy to use, you can use it to synchronize two machines quite easily. If you *push commits* (i.e. make some changes) to a Git *repository* (i.e. a directory with *history*) in one machine, you can synchronize or update its *clone* in another machine simply by *fetching* those new commits from the former repository  (called *upstream* in Git-speak).

Similar to SSH, Git can connect two machines over the internet for push/fetch only if at least one of them has a public IP address. As opposed to the <u>paid</u> SSH port forwarding services, however, one can have a <u>free</u>, if not private, online Git repository <u>with a public link</u> hosted in any of the popular Git-servers, such as https://github.com/, https://gitlab.com/, https://bitbucket.org/ or https://sourceforge.net/. Although anyone can view (and fetch) the contents of your online repository, you remain in control of who can make changes to your repository. This is because all push access is protected by your password or an access-token generated by you.

#### How GiBBERISh connects two hosts (client and server) over the internet without any of them having a public IP address 

Whenever the user enters a command in client, the GiBBERISh script encrypts it with your Git credentials  using a state-of-the-art, yet free, cryptography service called GNU Privacy Guard (**GPG**). It then commits this encrypted *text* to the user's local repository and pushes the same to the user's upstream repository (say, at GitHub). Server's script then fetches this commit from upstream, decrypts and pipes the user's command to an interactive Bash. The output emitted by bash is again encrypted, committed and pushed to GitHub, which the client fetches, decrypts and shows to the user. Simple, right? (*For an original implementation of a similar Git-based chat protocol, see https://github.com/ephigabay/GIC)*. Note that because only encrypted text goes to GitHub, the public cannot see what commands the user is running, or their outputs.

# Drawbacks:

Because of the dependence on an online Git repository (such as GitHub), the time between entering a command and getting its output back is not insignificant. From multiple measurements, I found the latency varies between 8 to 12 seconds.
# Features:

1. Doesn't require a public IP address. Both machines can be behind multiple NATs.
2. Doesn't care about firewalls and blocked ports.
3. Secure (everything public is encrypted with your password / access-token).
4. Interactive.
5. Easy and fast switching between local and remote environments without interrupting the remote session in any way. See *brb* in the *Keywords* section below.
6. Relays user's keyboard-generated signals, such as Ctrl-c; Ctrl-z to server.
7. Monitorability and overrides. If you grant someone else access to your local machine, for remote diagnostics for example, you will be shown all the commands she is executing in your terminal. You can also override those executions with Ctrl-c, Ctrl-z etc., if necessary.
8. Secure (GPG-encrypted) file transfer from client to server and vice-versa.
9. Forever free. Given the popularity of Git in DevOps, freemium services such as GitHub are here to stay and they probably will continue hosting small public repos for free for years to come. GiBBERISh is careful about keeping the repo size as small as possible. So, the size limit of the free-tier plans should never be an issue.
10. Lightweight. CPU usage is minimal. Polling and busy-waits are avoided wherever possible in favor of event-driven triggers.
11. Hassle-free installation, portability and flexibility. GiBBERISh only runs Git, and some basic Unix commands, all from a short, simple, stupid Bash script. Most current Linux distributions ship with Git and Bash both. Hence, GiBBERISh should run readily on those. You also hold the perpetual right to adapt the script to your needs.
12. Everything is under your control. You are free to modify the single Bash script that GiBBERISh runs from. You own and manage the upstream repository. If you are connecting to your work computer from your home machine or vice versa, you control both the machines. You also choose who can access your machine, should you ever be granting someone else remote access for purposes of diagnostics, instructions etc. [*Tip*: just revoke their (push) access-token from your upstream account once they are done].
13. Because Git and Bash are the only main ingredients, GiBBERISh (in its present form or another) maybe run easily on Windows using Git-Bash. But that won't probably be necessary, given that Windows 10 now ships with a subsystem for Linux (WSL).

# How to install / run

First, create a dedicated repository at any free Git hosting service (e.g. https://github.com/, https://gitlab.com/, https://bitbucket.org/ or https://sourceforge.net/). The repo can be completely empty, i.e. without any commits. *Tip*: Also generate, if possible, a personal access-token (PAT) for your account.

At the Linux machine that you want to use as server, run the *installer* script: 

```bash
./installer
```

Close and reopen the terminal to make the installation take effect.

To start the server, run: 

```bash
gibberish-server
```

At the client machine, install GiBBERISh similarly as above.

To access the remote server, simply run:

```bash
gibberish
```

After a long wait (yes I am ashamed of it), you will get the server's command prompt.

# Keywords

GiBBERISh recognizes a few keywords as listed below.

**ping | hello | hey | hi** : To test if the server is still connected. Consider the following situation. You are running a foreground process on the server, which outputs infrequently. Because it is in foreground, you do not have the command prompt and hence cannot execute a short command such as *echo* to see if the server is still responding. Just enter any of these keywords, and the server will send you a 'hello' if it can hear you, without interrupting that foreground process in any way. However, you can also do a simple Ctrl-z to get back the prompt, at the expense of stopping the foreground process. *Note*: If you enter any of these keywords at the command prompt, you are not given a new prompt after the server says hello. If this makes you uncomfortable, just press ENTER and wait for the server to give you another command prompt.

**exit | quit | logout | hup| bye** : To end the session and disconnect or hangup. When you do this, the current interactive shell in the server closes and a new, fresh shell launches ready for the next session. You therefore, would lose any environment variable you had set or function definitions you had sourced during the last session. Beware that this should also close any process running on the server that the exiting shell sends SIGHUP to, unless the process has a handler installed for HUP. Start processes in background with *nohup* if you intend to keep them running even after you logout. 

**brb** : Be right back, viz. to quickly switch to your local environment for a short while, without ending or interrupting the remote session. Any foreground process running in the server, keeps running uninterrupted. With this keyword, you simply get back your local prompt, whenever you need to run commands locally during a remote session. To return to the remote session, just enter 

```bash
gibberish
```

again. You will be shown all the server output since the time you **brb**d, so you miss nothing. *Note*: If you enter *brb* at the command prompt, you are not given a new prompt after you return to the session. If this makes you uncomfortable, just press ENTER and wait for the server to give you another command prompt.

**take | push **: See next section

# File and directory transfer

**Copying file from client to server:**

```bash
take <local path> <remote path> 
# or
push <local path> <remote path>
```

**Copying file from server to client:**

```bash
bring <remote path> <local path>
# or
pull <remote path> <local path>
```

To transfer directories or a collection of files, archive them first with [tar](https://man7.org/linux/man-pages/man1/tar.1.html) for example, and then use the above commands to exchange that single archive file.

*NOTE*: File transfer is end-to-end encrypted with your Git credentials. Because of this security, files are transferred using free public file hosting servers so that your Git repository size remains unaffected, no matter how big the transferred files are.

# Library, not executable

The bash script for GiBBERISh, viz. *gibberish_rc.bash*, is a library rather than an executable. On startup, interactive bash sources this script. The *installer* puts the corresponding run-command in .bashrc. The *installer*, on the other hand, is an executable script (hence, do a *chmod +x* on it, if necessary).

# Internals (pointers to understand the code)

The client-side and server-side codes are structurally almost the same. This is why a single shell-script suffices for both. There are two types of events. 1) Internal events: user (@client) or bash (@server) creates new data to push and 2) External events: git-fetch brings new data from outside to display or process. Internal events are mostly waited for, while external ones need to be polled for continuously. Everything else is mostly triggered by any of these events. E.g. upon creation, the data to be pushed is first siloed and an encrypt-commit-push pipeline is triggered.

The Git repository for GiBBERISh has two linear branches, viz. server and client. Server fetches from the server branch, but pushes to the client branch. Client does the converse. Every user-command or bash-output to be pushed, is committed to the proper outgoing branch as a single text file. As new commands/output become available, this file is simply revised to hold the same. The worktree therefore always contains only a single file, and all the commands/outputs can always be tracked from its revision history. Every time a commit happens, it triggers a post-commit hook that pushes the commit automatically.

Every iteration of fetch triggers a checkout sequence that tracks all the new commits chronologically, restoring the corresponding version of the abovementioned text file for decryption. Upon successful decryption, the checkout function pushes the data down a pipeline to user (@client) or bash (@server), before moving on to the next commit in the git-revision-list.

Note that if every user-command was passed using that single text file alone, then all the commands would end up in the queue for bash @server. To relay a user-generated signal (SIGINT, SIGTSTP, SIGQUIT) to a foreground process on demand, however, we need to route *kill* commands to a second, parallel shell in the server. We, therefore, need a way to commit commands in the repo other than the single text file mentioned before. GiBBERISh exploits Git's commit message field for this purpose. Only those commits that carry the user-generated control signals, or any other command that is to be executed by the parallel shell only, would have commit messages which hold the commands themselves. All other commits have empty commit messages. Whether the commit is meant for the main shell or the parallel, can therefore be ascertained simply by checking whether the commit message is empty or not. Commands meant for the parallel shell are mostly *kill* or file-download commands. Hence they do not contain any sensitive data and are therefore not encrypted to save on time. Such commands are called *hook*s. Hooks are the only way server can make client do some work, such as required during file transfer from server to client.

In contrast with SSH, GiBBERISh doesn't stream user's every key-stroke to the server. Rather, it first lets the user enter the complete command, reads it, checks for keywords, and only then decides what to do. If the command-line is not a keyword, it is pushed to the server as is for execution. To generate interrupt signals at server from particular key-sequences entered at the client, key-binding is done at the user's terminal such that it commits and pushes the appropriate callbacks to be executed by the parallel shell in server, whenever those keys are pressed by the user.

# Legal

GiBBERISh-- Git and Bash Based Encrypted Remote Interactive Shell

Copyright (C) 2021 Somajit Dey

You are free to modify and distribute the code under GPL-3.0-or-later <https://www.gnu.org/licenses/>

*GiBBERISh comes with ABSOLUTELY NO WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Use it at your own risk. The developer or copyright holder won't be liable for any damage done by or done using this software.*

